var countlist = function(n){ //returns [0 ... n-1]
    var countdown = function(n){//ugly. recursion vs desire to count up instead of down.
	if(n<=0) return [];
	return [n-1].concat(countdown(n-1));
    }
    countdown(n).reverse()
}

var whichmax = function(arr){ //returns index of max element (first index of tied max)
    reduce(function(i1,i2){if(arr[i1]>arr[i2])return i1; else return i2},0,countlist(arr.length))
}

var howesModel = function(){
    var p_orderr = .1;//fixed, for now
    var tolerance_A = 1;
    var tolerance_B = 1;
    
    var Aweight = gaussian({mu:1,sigma:1})
    var Bweight = gaussian({mu:1,sigma:1})

    var Aprior = Uniform({a:0,b:50}) //follows sim truth...
    var Bprior = Uniform({a:0,b:50})

    var howes_DM = function(optionlist,noise){
	
	var inferred_A1 = sample(Aprior);
	var inferred_B1 = sample(Bprior);
	var inferred_A2 = sample(Aprior);
	var inferred_B2 = sample(Bprior);
	var inferred_A3 = sample(Aprior);
	var inferred_B3 = sample(Bprior);

	var optioneval = function(){	
	    var calcobs = function(a,b,noise){
		return a*Aweight+b*Bweight+gaussian({mu:0,sigma:noise})
	    }
	    var ordrelation = function(a,b,tolerance,orderr){//these args are individual values...
		if(flip(orderr)) return categorical({vs:["<","=",">"],ps:[1,1,1]});
		if(Math.abs(a-b)<tolerance) return "=";
		if(a>b) return ">";
		if(a<b) return "<";
	    }

	    observe(Gaussian({mu:(inferred_A1*Aweight+inferred_B1*Bweight),sigma:noise}),calcobs(optionlist[0].a,optionlist[0].b,noise))
	    observe(Gaussian({mu:(inferred_A2*Aweight+inferred_B2*Bweight),sigma:noise}),calcobs(optionlist[1].a,optionlist[1].b,noise))
	    observe(Gaussian({mu:(inferred_A3*Aweight+inferred_B3*Bweight),sigma:noise}),calcobs(optionlist[2].a,optionlist[2].b,noise))
	    
	    condition( ordrelation(optionlist[0].a,optionlist[1].a,p_orderr) == ordrelation(inferred_A1,inferred_A2,tolerance_A,p_orderr));
	    condition( ordrelation(optionlist[0].a,optionlist[2].a,p_orderr) == ordrelation(inferred_A1,inferred_A3,tolerance_A,p_orderr));
	    condition( ordrelation(optionlist[1].a,optionlist[2].a,p_orderr) == ordrelation(inferred_A2,inferred_A3,tolerance_A,p_orderr));
	    condition( ordrelation(optionlist[0].a,optionlist[1].a,p_orderr) == ordrelation(inferred_B1,inferred_B2,tolerance_B,p_orderr));
	    condition( ordrelation(optionlist[0].a,optionlist[2].a,p_orderr) == ordrelation(inferred_B1,inferred_B3,tolerance_B,p_orderr));
	    condition( ordrelation(optionlist[1].a,optionlist[2].a,p_orderr) == ordrelation(inferred_B2,inferred_B3,tolerance_B,p_orderr));
	    
	    return whichmax([inferred_A1*Aweight+inferred_B1*Bweight,
			     inferred_A2*Aweight+inferred_B2*Bweight,
			     inferred_A3*Aweight+inferred_B3*Bweight,
			    ])+1; //whichmax returns 0 based index, choices labeled 1 2 3
	}//end optioneval
	var myeval = Infer({method:"SMC",samples:550,model:optioneval})
	var scores = [myeval.score(1),myeval.score(2),myeval.score(3)]
	return whichmax(scores)+1;
    }//end DM
    
    var dfrow_to_optionlist = function(arow){
	return [{a:arow["A1"],b:arow["B1"]}, {a:arow["A2"],b:arow["B2"]}, {a:arow["A3"],b:arow["B3"]}]
    }

    var observe_row = function(arow){
	//condition(linear_DM(dfrow_to_optionlist(arow),arow["sim.noise"])==arow["simchoice"])
	var idecide = howes_DM(dfrow_to_optionlist(arow),arow["sim.noise"]);
	//	console.log("observe_row");
	//	console.log(idecide+"=="+arow["simchoice"]);
	condition(howes_DM(dfrow_to_optionlist(arow),arow["sim.noise"])==arow["simchoice"]);
    }
    map(observe_row,expdf)
    return [Aweight,Bweight];
}//end howesModel

Infer({method:"SMC",samples:1000,model:howesModel})
