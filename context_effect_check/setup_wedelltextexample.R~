library(ggplot2)
library(dplyr)
library(tidyr)
library(rwebppl)

##Loop calling this with various setup args follows...
starttime <- Sys.time();
hm_ppnts = 100;
hm_trials = 4; #fixed by textexample

##Fixed decison maker params: might be important here?
calc_sd = rep(3,hm_ppnts) #abs(rnorm(hm_ppnts,3,.5))
tolerance_prob = rep(.011, hm_ppnts) #rbeta(hm_ppnts,1,20)+.01
tolerance_payoff = rep(1.1 ,hm_ppnts)#abs(rnorm(hm_ppnts,1,1))+1
p_err = rep(.01,hm_ppnts);

set.seed(4) #should fix the stimuli generated for each call (with the same number of total stimuli). Check this is true by returning the max expected.
source(paste0("wedellExp1Stim.R"))
mystim <- getStim_twomatrixformat(hm_trials,getWedelltrial)

prob <- mystim[[1]]
payoff <- mystim[[2]]

simexp.df <- data.frame(ppntid=c(),calc_sd=c(),tolerance_prob=c(), tolerance_payoff=c(),p_err=c(),trialid=c(),probA=c(),probB=c(),probC=c(),payoffA=c(),payoffB=c(),payoffC=c()); #via df rather than directly to datalist for convenient inspection.

impressionrow <- 1;
for(ppnt in 1:hm_ppnts){
    for(trial in 1:hm_trials){
        simexp.df[impressionrow,"ppntid"] <- ppnt-1;#puts ids on webppls's 0 indexed scale. Remember to undo this at the other end.
        simexp.df[impressionrow,"calc_sd"] <- calc_sd[ppnt];
        simexp.df[impressionrow,"tolerance_prob"] <- tolerance_prob[ppnt];
        simexp.df[impressionrow,"tolerance_payoff"] <- tolerance_payoff[ppnt];
        simexp.df[impressionrow,"p_err"] <- p_err[ppnt];
        simexp.df[impressionrow,"trialid"] <- trial;
        simexp.df[impressionrow,"probA"] <- prob[trial,1]
        simexp.df[impressionrow,"probB"] <- prob[trial,2]
        simexp.df[impressionrow,"probC"] <- prob[trial,3]
        simexp.df[impressionrow,"payoffA"] <- payoff[trial,1]
        simexp.df[impressionrow,"payoffB"]<- payoff[trial,2]
        simexp.df[impressionrow,"payoffC"]<- payoff[trial,3]
        
        impressionrow <- impressionrow+1;#lazy rowfinder.
    }
}

##add simulated choices
timer <- system.time(
    agentstuff <- webppl(program_file="howes16_full.ppl",data=simexp.df,data_var="expdf")
)

##you could just add the choices (agentstuff[[8]]), 
simexp.df$choice <- agentstuff[[8]] ##DONE

##all the other stuff is just here to inspect the model's working-out.
calcobs <- agentstuff[[1]]
simexp.df$calcA <- calcobs[,1]
simexp.df$calcB <- calcobs[,2]
simexp.df$calcC <- calcobs[,3]

simexp.df$ABprob <- agentstuff[[2]]
simexp.df$ACprob <- agentstuff[[3]]
simexp.df$BCprob <- agentstuff[[4]]

simexp.df$ABpayoff <- agentstuff[[5]]
simexp.df$ACpayoff <- agentstuff[[6]]
simexp.df$BCpayoff <- agentstuff[[7]]


##expected values for reference
simexp.df$exValA <- simexp.df$probA*simexp.df$payoffA
simexp.df$exValB <- simexp.df$probB*simexp.df$payoffB
simexp.df$exValC <- simexp.df$probC*simexp.df$payoffC

##expected value of chosen option
for(i in 1:nrow(simexp.df)){
    simexp.df[i,"val_chosen"] <- simexp.df[i,c("exValA","exValB","exValC")][,simexp.df[i,"choice"]];
    simexp.df[i,"best_available"] <- simexp.df[i,c("exValA","exValB","exValC")][,which(simexp.df[i,c("exValA","exValB","exValC")]==max(simexp.df[i,c("exValA","exValB","exValC")]))[1]]
    simexp.df[i,"agent_loss"] <- simexp.df[i,"val_chosen"]-simexp.df[i,"best_available"]
    simexp.df[i,"val_randomchoice"] <- simexp.df[i,c("exValA","exValB","exValC")][,base::sample(1:3,1)];
    simexp.df[i,"randomChoice_loss"] <-simexp.df[i,"val_randomchoice"]-simexp.df[i,"best_available"]  
}

write.csv(simexp.df,file=paste0("simexp.csv"),row.names=FALSE)

endtime=Sys.time();
