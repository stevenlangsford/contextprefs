rm(list=ls())
library(ggplot2)
library(dplyr)
library(rwebppl)

set.seed(4) #chosen by fair dice roll.

hm_ppnts = 30;
hm_trials = 30; #per participant, not total.

##agent params:
calc_sd = abs(rnorm(hm_ppnts,3,.5))
tolerance_prob = rbeta(hm_ppnts,1,20)+.01
tolerance_payoff = abs(rnorm(hm_ppnts,1,1))+1
p_err = rep(.01,hm_ppnts);


source("wedellExp1Stim.R")
mystim <- getStim_twomatrixformat(hm_trials,getRandomtrial)
prob <- mystim[[1]]
payoff <- mystim[[2]]

simexp.df <- data.frame(ppntid=c(),calc_sd=c(),tolerance_prob=c(), tolerance_payoff=c(),p_err=c(),trialid=c(),probA=c(),probB=c(),probC=c(),payoffA=c(),payoffB=c(),payoffC=c()); #via df rather than directly to datalist for convenient inspection.

impressionrow <- 1;
for(ppnt in 1:hm_ppnts){
    for(trial in 1:hm_trials){
        simexp.df[impressionrow,"ppntid"] <- ppnt-1;#puts ids on webppls's 0 indexed scale. Remember to undo this at the other end.
        simexp.df[impressionrow,"calc_sd"] <- calc_sd[ppnt];
        simexp.df[impressionrow,"tolerance_prob"] <- tolerance_prob[ppnt];
        simexp.df[impressionrow,"tolerance_payoff"] <- tolerance_payoff[ppnt];
        simexp.df[impressionrow,"p_err"] <- p_err[ppnt];
        simexp.df[impressionrow,"trialid"] <- trial;
        simexp.df[impressionrow,"probA"] <- prob[trial,1]
        simexp.df[impressionrow,"probB"] <- prob[trial,2]
        simexp.df[impressionrow,"probC"] <- prob[trial,3]
        simexp.df[impressionrow,"payoffA"] <- payoff[trial,1]
        simexp.df[impressionrow,"payoffB"]<- payoff[trial,2]
        simexp.df[impressionrow,"payoffC"]<- payoff[trial,3]
        
        impressionrow <- impressionrow+1;#lazy rowfinder.
    }
}

##add simulated choices
     timer <- system.time(
         #simexp.df$choice
         agentstuff <- webppl(program_file="choicemaker.ppl",data=simexp.df,data_var="expdf")
     )
##you could just add the choices (agentstuff[[8]]), 
simexp.df$choice <- agentstuff[[8]] ##DONE

##all the other stuff is just here to inspect the model's working-out.
saveplots <- TRUE; plot.dir="./rnd_stim_plots/";

calcobs <- agentstuff[[1]]
simexp.df$calcA <- calcobs[,1]
simexp.df$calcB <- calcobs[,2]
simexp.df$calcC <- calcobs[,3]

simexp.df$ABprob <- agentstuff[[2]]
simexp.df$ACprob <- agentstuff[[3]]
simexp.df$BCprob <- agentstuff[[4]]

simexp.df$ABpayoff <- agentstuff[[5]]
simexp.df$ACpayoff <- agentstuff[[6]]
simexp.df$BCpayoff <- agentstuff[[7]]


##expected values for reference
simexp.df$exValA <- simexp.df$probA*simexp.df$payoffA
simexp.df$exValB <- simexp.df$probB*simexp.df$payoffB
simexp.df$exValC <- simexp.df$probC*simexp.df$payoffC

##check the calc observation looks like you'd expect:
calcvstruth.plot <- ggplot(simexp.df,aes(x=exValA,y=calcA))+geom_point()+
    xlab("Option A value in expectation")+
    ylab("Agent's calc observation")+
    theme_bw()
if(saveplots)ggsave(calcvstruth.plot,file=paste0(plot.dir,"calcvstruth.png"));

##check the ord observation looks like you'd expect:
check_ordobs <- function(a,b,tolerance,ordobs){
    if(abs(a-b)<tolerance){
        true_relation="="
    }else if (a>b){
        true_relation=">"
    }else {
        true_relation="<"
    }
    return(ordobs==true_relation);
}

ordobs_errorrate_check.df <- data.frame(
ABprob= sum(as.logical(map(1:nrow(simexp.df),function(i){
    with(simexp.df[i,],check_ordobs(probA,probB,tolerance_prob,ABprob))
})))/nrow(simexp.df),
ACprob = sum(as.logical(map(1:nrow(simexp.df),function(i){
    with(simexp.df[i,],check_ordobs(probA,probC,tolerance_prob,ACprob))
})))/nrow(simexp.df),
BCprob= sum(as.logical(map(1:nrow(simexp.df),function(i){
    with(simexp.df[i,],check_ordobs(probB,probC,tolerance_prob,BCprob))
})))/nrow(simexp.df),
ABpayoff=sum(as.logical(map(1:nrow(simexp.df),function(i){
    with(simexp.df[i,],check_ordobs(payoffA,payoffB,tolerance_payoff,ABpayoff))
})))/nrow(simexp.df),
ACpayoff=sum(as.logical(map(1:nrow(simexp.df),function(i){
    with(simexp.df[i,],check_ordobs(payoffA,payoffC,tolerance_payoff,ACpayoff))
})))/nrow(simexp.df),
BCpayoff=sum(as.logical(map(1:nrow(simexp.df),function(i){
    with(simexp.df[i,],check_ordobs(payoffB,payoffC,tolerance_payoff,BCpayoff))
})))/nrow(simexp.df)
    )

errate_plotable.df <- gather(ordobs_errorrate_check.df,comparison,err.rate)

ord_error.plot <- ggplot(errate_plotable.df,aes(x=comparison,group=comparison,y=err.rate))+
    geom_bar(stat="identity")+
    coord_cartesian(ylim=c(.95,1))+
    geom_hline(aes(yintercept = 1-mean(p_err)+(1/3)*mean(p_err),color="expected"),width=2)+
    xlab("Comparison")+
    ylab("Proportion correct")
if(saveplots)ggsave(ord_error.plot,file=paste0(plot.dir,"ordrelation_errors.png"));

##expected value of chosen option
for(i in 1:nrow(simexp.df)){
    simexp.df[i,"val_chosen"] <- simexp.df[i,c("exValA","exValB","exValC")][,simexp.df[i,"choice"]];
    simexp.df[i,"best_available"] <- simexp.df[i,c("exValA","exValB","exValC")][,which(simexp.df[i,c("exValA","exValB","exValC")]==max(simexp.df[i,c("exValA","exValB","exValC")]))[1]]
    simexp.df[i,"agent_loss"] <- simexp.df[i,"val_chosen"]-simexp.df[i,"best_available"]
    simexp.df[i,"val_randomchoice"] <- simexp.df[i,c("exValA","exValB","exValC")][,base::sample(1:3,1)];
    simexp.df[i,"randomChoice_loss"] <-simexp.df[i,"val_randomchoice"]-simexp.df[i,"best_available"]  
    }


performance.plot <- ggplot(simexp.df)+geom_density(aes(x=randomChoice_loss,color="guesser"))+
    geom_density(aes(x=agent_loss,color="agent"))+
    xlab("Chosen - best_available (in expectation)")+
     theme_bw()
if(saveplots)ggsave(performance.plot,file=paste0(plot.dir,"agentvsguesser.png"));
##Todo: more checks that sim choice is working! Ok, so it's doing slightly better than chance... that's not very reassuring yet!
##Ideally go look for those context effects! Can you return or otherwise inspect the calc and ord observations? That'd be good...

##Then, go do some param recovery on these sim data sets... but remember a bunch of bugfixes popped up in the choice sim code, so it's drifted away from the param_inference code... need to go fix them bugs in param-recovery! Oh deary me.
